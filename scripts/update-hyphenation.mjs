#!/usr/bin/env node
// Downloads binary tries from typst/hypher and generates C headers.
// Usage: node scripts/update-hyphenation.mjs [lang...]
//   node scripts/update-hyphenation.mjs ru en

import { writeFileSync, mkdirSync } from "fs";
import { dirname, resolve } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = resolve(__dirname, "..");
const OUTPUT_DIR = resolve(PROJECT_ROOT, "lib/Hyphenation/generated");
const DEFAULT_LANGUAGES = ["de", "en", "es", "fr", "it", "ru", "uk"];
const BYTES_PER_LINE = 19;
const BASE_URL =
  "https://github.com/typst/hypher/raw/refs/heads/main/tries/";

function formatBytes(buf) {
  const lines = [];
  for (let i = 0; i < buf.length; i += BYTES_PER_LINE) {
    const chunk = [];
    for (let j = i; j < Math.min(i + BYTES_PER_LINE, buf.length); j++) {
      chunk.push(`0x${buf[j].toString(16).toUpperCase().padStart(2, "0")}`);
    }
    lines.push(`    ${chunk.join(", ")},`);
  }
  if (lines.length === 0) {
    lines.push("    0x00,");
  }
  return lines.join("\n");
}

function writeHeader(outputPath, blob, symbol) {
  if (blob.length < 4) {
    throw new Error(`Blob too small: ${blob.length} bytes`);
  }

  const rootAddr =
    (blob[0] << 24) | (blob[1] << 16) | (blob[2] << 8) | blob[3];

  if (rootAddr < 4 || rootAddr > blob.length) {
    throw new Error(
      `Root address ${rootAddr} out of valid range [4, ${blob.length}]`
    );
  }

  const data = blob.subarray(4);
  const bytesLiteral = formatBytes(data);
  const rootAddrNew = rootAddr - 4;
  const dataSymbol = `${symbol}_trie_data`;
  const patternsSymbol = `${symbol}_patterns`;
  const rootHex = `0x${rootAddrNew.toString(16).toUpperCase().padStart(2, "0")}`;

  const content = `#pragma once

#include <cstddef>
#include <cstdint>

#include "../SerializedHyphenationTrie.h"

// Auto-generated by update-hyphenation.mjs. Do not edit manually.
alignas(4) constexpr uint8_t ${dataSymbol}[] = {
${bytesLiteral}
};

constexpr SerializedHyphenationPatterns ${patternsSymbol} = {
    ${rootHex}u,
    ${dataSymbol},
    sizeof(${dataSymbol}),
};
`;

  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, content);
}

async function downloadTrie(lang) {
  const url = `${BASE_URL}${lang}.bin`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download ${url}: ${response.status}`);
  }
  return new Uint8Array(await response.arrayBuffer());
}

async function main() {
  const args = process.argv.slice(2);
  const languages = args.length > 0 ? args : DEFAULT_LANGUAGES;

  mkdirSync(OUTPUT_DIR, { recursive: true });

  for (const lang of languages) {
    process.stdout.write(`Processing language: ${lang}\n`);

    const blob = await downloadTrie(lang);
    if (blob.length === 0) {
      throw new Error(`Empty trie for language: ${lang}`);
    }

    const outputPath = resolve(OUTPUT_DIR, `hyph-${lang}.trie.h`);
    const symbol = lang.replace(/-/g, "_");
    writeHeader(outputPath, blob, symbol);

    process.stdout.write(
      `  Generated ${outputPath} (${blob.length} bytes payload)\n`
    );
  }

  process.stdout.write(`Done! Generated patterns for: ${languages.join(" ")}\n`);
}

main().catch((err) => {
  process.stderr.write(`Error: ${err.message}\n`);
  process.exit(1);
});
