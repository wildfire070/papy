#!/usr/bin/env python3
"""Generate NFC composition table for UTF-8 normalization.

Outputs lib/Utf8/Utf8NfcTable.h â€” a PROGMEM sorted array of {base, combining, result}
tuples covering compositions for codepoints our fonts actually have (Latin, Greek,
Cyrillic ranges up to U+04FF, plus common combining marks).

Usage:
    python3 scripts/generate-nfc-table.py > lib/Utf8/Utf8NfcTable.h
    # or:  uv run scripts/generate-nfc-table.py > lib/Utf8/Utf8NfcTable.h
"""

import unicodedata
import sys


def get_canonical_compositions():
    """Extract canonical compositions from Unicode data.

    Returns sorted list of (base, combining, composed) tuples.
    Only includes compositions where the result codepoint is in ranges
    our fonts support.
    """
    compositions = []

    # Ranges our fonts support (Latin, Greek, Cyrillic, Latin Extended Additional)
    SUPPORTED_RANGES = [
        (0x0000, 0x04FF),   # Basic Latin through Cyrillic
        (0x1E00, 0x1EFF),   # Latin Extended Additional (Vietnamese)
        (0x1F00, 0x1FFF),   # Greek Extended
    ]

    def in_supported_range(cp):
        return any(lo <= cp <= hi for lo, hi in SUPPORTED_RANGES)

    # Iterate over all Unicode codepoints and find those with canonical decompositions
    for cp in range(0x0080, 0x10000):
        if not in_supported_range(cp):
            continue

        decomp = unicodedata.decomposition(chr(cp))
        if not decomp:
            continue

        # Skip compatibility decompositions (they start with a tag like <compat>)
        if decomp.startswith('<'):
            continue

        parts = decomp.split()
        if len(parts) != 2:
            continue

        base = int(parts[0], 16)
        combining = int(parts[1], 16)

        # Exclusion list: compositions excluded from NFC
        # (Composition Exclusions from Unicode standard)
        # We skip singleton decompositions and non-starter decompositions
        # by checking that combining > 0 and is actually a combining character
        cat = unicodedata.category(chr(combining))
        if not cat.startswith('M'):
            # combining part must be a Mark (combining character)
            # Some decompositions have two base characters (e.g., ligatures)
            continue

        compositions.append((base, combining, cp))

    # Sort by (base, combining) for binary search
    compositions.sort()
    return compositions


def main():
    compositions = get_canonical_compositions()

    print("#pragma once")
    print()
    print("// Auto-generated by scripts/generate-nfc-table.py")
    print("// Canonical NFC composition table for Latin, Greek, Cyrillic ranges.")
    print(f"// {len(compositions)} entries, ~{len(compositions) * 6} bytes in flash.")
    print()
    print("#include <cstdint>")
    print()
    print("#ifdef ESP_PLATFORM")
    print("#include <pgmspace.h>")
    print("#else")
    print("#ifndef PROGMEM")
    print("#define PROGMEM")
    print("#endif")
    print("#endif")
    print()
    print("struct NfcComposition {")
    print("  uint16_t base;")
    print("  uint16_t combining;")
    print("  uint16_t result;")
    print("};")
    print()
    print(f"constexpr size_t NFC_TABLE_SIZE = {len(compositions)};")
    print()
    print("static const NfcComposition NFC_TABLE[] PROGMEM = {")

    for base, combining, result in compositions:
        base_char = chr(base)
        combining_name = unicodedata.name(chr(combining), "?")
        result_char = chr(result)
        result_name = unicodedata.name(chr(result), "?")
        print(f"    {{0x{base:04X}, 0x{combining:04X}, 0x{result:04X}}},  "
              f"// {base_char} + {combining_name} = {result_char} ({result_name})")

    print("};")

    print(f"\n// Total: {len(compositions)} compositions", file=sys.stderr)


if __name__ == "__main__":
    main()
